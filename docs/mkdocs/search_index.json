{
    "docs": [
        {
            "location": "/",
            "text": "ZF2 Auto Table Documentation\n\n\nWelcome!\n\n\nUse the navigation on the left to find what you need.\n\n\nTo get started, you should take a look at \nInstallation\n or \nRetrieving Records\n.\n\n\nYou can also jump right into the \nconfiguration options\n.",
            "title": "Home"
        },
        {
            "location": "/#zf2-auto-table-documentation",
            "text": "Welcome!  Use the navigation on the left to find what you need.  To get started, you should take a look at  Installation  or  Retrieving Records .  You can also jump right into the  configuration options .",
            "title": "ZF2 Auto Table Documentation"
        },
        {
            "location": "/install/",
            "text": "Installation\n\n\nThe simplest way to install is to use \ncomposer\n:\n\n\nphp composer.phar require nathanjosiah/zf2-autotable:dev-master\n\n\n\n\nThen, enable the module in your application config (typically \nconfig/app.config.php\n) under \nmodules\n. For example:\n\n\n<?php\n$config =  [\n  'modules' => [\n    'AutoTable', // Added here\n    'Application',\n    'OtherModules',\n  ],\n  // ...\n];\n\n\n\n\nNow you can start configuring your \nServiceManager\n as demonstrated in the rest of the documentation.",
            "title": "Installation"
        },
        {
            "location": "/install/#installation",
            "text": "The simplest way to install is to use  composer :  php composer.phar require nathanjosiah/zf2-autotable:dev-master  Then, enable the module in your application config (typically  config/app.config.php ) under  modules . For example:  <?php\n$config =  [\n  'modules' => [\n    'AutoTable', // Added here\n    'Application',\n    'OtherModules',\n  ],\n  // ...\n];  Now you can start configuring your  ServiceManager  as demonstrated in the rest of the documentation.",
            "title": "Installation"
        },
        {
            "location": "/retrieving/",
            "text": "Retrieving Records\n\n\nFlat record\n\n\nUsing the following table \narticles\n:\n\n\n\n\n\n\n\n\nid\n\n\ntitle\n\n\n\n\n\n\n\n\n\n\n1\n\n\nSweet Baby Ray's is the best!\n\n\n\n\n\n\n2\n\n\nPB&J is yummy\n\n\n\n\n\n\n3\n\n\nI like Jellyfish\n\n\n\n\n\n\n\n\nFirst model the table:\n\n\nnamespace Application\\Model;\nclass Article {\n  public $id,$title;\n}\n\n\n\n\nThen in the config:\n\n\n'auto_tables' => [\n  'articles' => [\n    'table_name' => 'articles',\n    'entity' => \\Application\\Model\\Article::class,\n    'hydrator' => \\Zend\\Hydrator\\ObjectProperty::class,\n  ]\n]\n\n\n\n\nAnd finally, simple use it:\n\n\n// $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n$table = $manager->get('articles');\n$entity = $table->fetchWithId(2);\n\n// Outputs: \"PB&J is yummy\"\necho $entity->title;\n\n\n\n\nOne-to-One relationships\n\n\nWith a table \narticles\n:\n\n\n\n\n\n\n\n\nid\n\n\ntitle\n\n\nauthor\n\n\n\n\n\n\n\n\n\n\n1\n\n\nSweet Baby Ray's is the best!\n\n\n1\n\n\n\n\n\n\n2\n\n\nPB&J is yummy\n\n\n1\n\n\n\n\n\n\n3\n\n\nI like Jellyfish\n\n\n2\n\n\n\n\n\n\n\n\nand another table \nauthors\n:\n\n\n\n\n\n\n\n\nid\n\n\nname\n\n\n\n\n\n\n\n\n\n\n1\n\n\nNathan Smith\n\n\n\n\n\n\n2\n\n\nFake Name\n\n\n\n\n\n\n\n\nStart by modeling the entity for both:\n\n\nThe article:\n\n\nnamespace Application\\Model;\nclass Article {\n  public $id,$title,$author;\n}\n\n\n\n\nand the author\n\n\nnamespace Application\\Model;\nclass Author {\n  public $id,$name;\n}\n\n\n\n\nThen in the config, define both the \narticles\n and \nauthors\n table and use the \nlinked_tables\n key to configure the relationship:\n\n\n'auto_tables' => [\n  'articles' => [\n    'table_name' => 'articles',\n    'entity' => \\Application\\Model\\Article::class,\n    'hydrator' => \\Zend\\Hydrator\\ObjectProperty::class,\n    'linked_tables' => [\n      'author' => [\n        'name' => 'authors',\n        'type' => 'one_to_one',\n      ]\n    ]\n  ],\n  'authors' => [\n    'table_name' => 'authors',\n    'entity' => \\Application\\Model\\Author::class,\n    'hydrator' => \\Zend\\Hydrator\\ObjectProperty::class,\n  ]\n]\n\n\n\n\nThen use it:\n\n\n// $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n$table = $manager->get('articles');\n$article = $table->fetchWithId(3);\n\n// Outputs: \"I like Jellyfish\"\necho $article->title;\n\n// Outputs: \"Fake Name\"\necho $article->author->name;\n\n\n\n\nOne-to-Many relationships\n\n\nWith a table \narticles\n:\n\n\n\n\n\n\n\n\nid\n\n\ntitle\n\n\n\n\n\n\n\n\n\n\n1\n\n\nSweet Baby Ray's is the best!\n\n\n\n\n\n\n2\n\n\nPB&J is yummy\n\n\n\n\n\n\n3\n\n\nI like Jellyfish\n\n\n\n\n\n\n\n\nand another table \ncomments\n:\n\n\n\n\n\n\n\n\nid\n\n\ncomment\n\n\narticle_id\n\n\n\n\n\n\n\n\n\n\n1\n\n\nThis is the best article ever!\n\n\n1\n\n\n\n\n\n\n2\n\n\nI hated this!\n\n\n1\n\n\n\n\n\n\n3\n\n\nI am a lost prince and I have money.\n\n\n2\n\n\n\n\n\n\n\n\nStart by modeling the entity for both:\n\n\nThe article:\n\n\nnamespace Application\\Model;\nclass Article {\n  public $id,$title;\n}\n\n\n\n\nand the author\n\n\nnamespace Application\\Model;\nclass Comment {\n  public $id,$comment;\n}\n\n\n\n\nThen in the config, define both the \narticles\n and \ncomments\n table and use the \nlinked_tables\n key to configure the relationship:\n\n\n'auto_tables' => [\n  'articles' => [\n    'table_name' => 'articles',\n    'entity' => \\Application\\Model\\Article::class,\n    'hydrator' => \\Zend\\Hydrator\\ObjectProperty::class,\n    'linked_tables' => [\n      'author' => [\n        'name' => 'authors',\n        'type' => 'one_to_many',\n        'remote_column' => 'arcticle_id',\n        'local_column' => 'id',\n      ]\n    ]\n  ],\n  'comments' => [\n    'table_name' => 'comments',\n    'entity' => \\Application\\Model\\Comment::class,\n    'hydrator' => \\Zend\\Hydrator\\ObjectProperty::class,\n  ]\n]\n\n\n\n\nThen use it:\n\n\n// $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n$table = $manager->get('articles');\n$article = $table->fetchWithId(1);\n\n// Outputs: \"Sweet Baby Ray's is the best!\"\necho $article->title;\n\n// Outputs: \"This is the best article ever!\" and \"I hated this!\"\nforeach($article->comments as $comment) {\n  echo $comment->comment;\n}\n\n\n\n\nMany-to-many relationships\n\n\nWith a table \narticles\n:\n\n\n\n\n\n\n\n\nid\n\n\ntitle\n\n\n\n\n\n\n\n\n\n\n1\n\n\nSweet Baby Ray's is the best!\n\n\n\n\n\n\n2\n\n\nPB&J is yummy\n\n\n\n\n\n\n3\n\n\nI like Jellyfish\n\n\n\n\n\n\n\n\nand another table \nauthors\n:\n\n\n\n\n\n\n\n\nid\n\n\nName\n\n\n\n\n\n\n\n\n\n\n1\n\n\nNathan Smith\n\n\n\n\n\n\n2\n\n\nFake Name\n\n\n\n\n\n\n3\n\n\nJimmy Boi\n\n\n\n\n\n\n4\n\n\nJohn Doe\n\n\n\n\n\n\n\n\nand a mapping table \narticles_authors_map\n:\n\n\n\n\n\n\n\n\narticle_id\n\n\nauthor_id\n\n\n\n\n\n\n\n\n\n\n1\n\n\n1\n\n\n\n\n\n\n1\n\n\n3\n\n\n\n\n\n\n2\n\n\n3\n\n\n\n\n\n\n3\n\n\n4\n\n\n\n\n\n\n3\n\n\n2\n\n\n\n\n\n\n\n\nStart by modeling the entity for both:\n\n\nThe article:\n\n\nnamespace Application\\Model;\nclass Article {\n  public $id,$title,$authors;\n}\n\n\n\n\nand the author\n\n\nnamespace Application\\Model;\nclass Author {\n  public $id,$name,$articles;\n}\n\n\n\n\nThen in the config, define both the \narticles\n , \nauthors\n, and \narticles_authors_map\n tables and use the \nlinked_tables\n key for the \narticles\n and \nauthors\n table to configure the two-way relationship:\n\n\n'auto_tables' => [\n  'articles' => [\n    'table_name' => 'articles',\n    'entity' => \\Application\\Model\\Article::class,\n    'hydrator' => \\Zend\\Hydrator\\ObjectProperty::class,\n    'linked_tables' => [\n      'authors' => [\n        'type' => 'many_to_many',\n        'remote_table' => 'authors',\n        'mapping_table' => 'articles_authors_map',\n        'local_column' => 'id',\n        'local_property' => 'id',\n        'local_mapping_column' => 'article_id',\n        'remote_mapping_column' => 'author_id',\n        'remote_column' => 'id',\n      ]\n    ]\n  ],\n  'authors' => [\n    'table_name' => 'authors',\n    'entity' => \\Application\\Model\\Author::class,\n    'hydrator' => \\Zend\\Hydrator\\ObjectProperty::class,\n    'linked_tables' => [\n      'articles' => [\n        'type' => 'many_to_many',\n        'remote_table' => 'authors',\n        'mapping_table' => 'articles_authors_map',\n        'local_column' => 'id',\n        'local_property' => 'id',\n        'local_mapping_column' => 'author_id',\n        'remote_mapping_column' => 'article_id',\n        'remote_column' => 'id',\n      ]\n    ]\n  ],\n  'articles_authors_map' => [\n    'table_name' => 'articles_authors_map',\n  ]\n]\n\n\n\n\nThen use it:\n\n\n// $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n$table = $manager->get('articles');\n$article = $table->fetchWithId(3);\n\n// Outputs: \"I like Jellyfish\"\necho $article->title;\n\n// Outputs: \"John Doe\" and \"Fake Name\"\nforeach($article->authors as $author) {\n  echo $author->name;\n}\n\n$table = $manager->get('authors');\n$author = $table->fetchWithId(3);\n\n// Outputs: \"Jimmy Boi\"\necho $author->name;\n\n// Outputs: \"Sweet Baby Ray's is the best!\" and \"PB&J is yummy\"\nforeach($author->articles as $article) {\n  echo $article->title;\n}\n\n\n\n\nRelationships aren't one level deep\n\n\nAny linked tabled contain all the defined relationships all the time\n\n\nWith a table \narticles\n:\n\n\n\n\n\n\n\n\nid\n\n\ntitle\n\n\nauthor\n\n\n\n\n\n\n\n\n\n\n1\n\n\nSweet Baby Ray's is the best!\n\n\n1\n\n\n\n\n\n\n2\n\n\nPB&J is yummy\n\n\n1\n\n\n\n\n\n\n3\n\n\nI like Jellyfish\n\n\n2\n\n\n\n\n\n\n\n\nand another table \nauthors\n:\n\n\n\n\n\n\n\n\nid\n\n\nName\n\n\nCar\n\n\n\n\n\n\n\n\n\n\n1\n\n\nNathan Smith\n\n\n2\n\n\n\n\n\n\n2\n\n\nFake Name\n\n\n1\n\n\n\n\n\n\n\n\nand another table \ncars\n:\n\n\n\n\n\n\n\n\nid\n\n\nname\n\n\n\n\n\n\n\n\n\n\n1\n\n\nHonda Civic\n\n\n\n\n\n\n2\n\n\nTesla Model 3\n\n\n\n\n\n\n\n\nStart by modeling the entity for all:\n\n\nThe article:\n\n\nnamespace Application\\Model;\nclass Article {\n  public $id,$title,$author;\n}\n\n\n\n\nand the author\n\n\nnamespace Application\\Model;\nclass Author {\n  public $id,$name,$car;\n}\n\n\n\n\nand the car\n\n\nnamespace Application\\Model;\nclass Car {\n  public $id,$name,$car;\n}\n\n\n\n\nThen in the config, define the \narticles\n,  \nauthors\n, and \ncars\n tables and use the \nlinked_tables\n key to configure the relationships:\n\n\n'auto_tables' => [\n  'articles' => [\n    'table_name' => 'articles',\n    'entity' => \\Application\\Model\\Article::class,\n    'hydrator' => \\Zend\\Hydrator\\ObjectProperty::class,\n    'linked_tables' => [\n      'author' => [\n        'name' => 'authors',\n        'type' => 'one_to_one',\n      ]\n    ]\n  ],\n  'authors' => [\n    'table_name' => 'authors',\n    'entity' => \\Application\\Model\\Author::class,\n    'hydrator' => \\Zend\\Hydrator\\ObjectProperty::class,\n    'linked_tables' => [\n      'car' => [\n        'name' => 'cars',\n        'type' => 'one_to_one',\n      ]\n    ]\n  ],\n  'cars' => [\n    'table_name' => 'cars',\n    'entity' => \\Application\\Model\\Car::class,\n    'hydrator' => \\Zend\\Hydrator\\ObjectProperty::class,\n  ]\n]\n\n\n\n\nThen use it:\n\n\n// $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n$table = $manager->get('articles');\n$article = $table->fetchWithId(3);\n\n// Outputs: \"I like Jellyfish\"\necho $article->title;\n\n// Outputs: \"Fake Name\"\necho $article->author->name;\n\n// Outputs: \"Honda Civic\"\necho $article->author->car->name;",
            "title": "Retrieve Records"
        },
        {
            "location": "/retrieving/#retrieving-records",
            "text": "",
            "title": "Retrieving Records"
        },
        {
            "location": "/retrieving/#flat-record",
            "text": "Using the following table  articles :     id  title      1  Sweet Baby Ray's is the best!    2  PB&J is yummy    3  I like Jellyfish     First model the table:  namespace Application\\Model;\nclass Article {\n  public $id,$title;\n}  Then in the config:  'auto_tables' => [\n  'articles' => [\n    'table_name' => 'articles',\n    'entity' => \\Application\\Model\\Article::class,\n    'hydrator' => \\Zend\\Hydrator\\ObjectProperty::class,\n  ]\n]  And finally, simple use it:  // $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n$table = $manager->get('articles');\n$entity = $table->fetchWithId(2);\n\n// Outputs: \"PB&J is yummy\"\necho $entity->title;",
            "title": "Flat record"
        },
        {
            "location": "/retrieving/#one-to-one-relationships",
            "text": "With a table  articles :     id  title  author      1  Sweet Baby Ray's is the best!  1    2  PB&J is yummy  1    3  I like Jellyfish  2     and another table  authors :     id  name      1  Nathan Smith    2  Fake Name     Start by modeling the entity for both:  The article:  namespace Application\\Model;\nclass Article {\n  public $id,$title,$author;\n}  and the author  namespace Application\\Model;\nclass Author {\n  public $id,$name;\n}  Then in the config, define both the  articles  and  authors  table and use the  linked_tables  key to configure the relationship:  'auto_tables' => [\n  'articles' => [\n    'table_name' => 'articles',\n    'entity' => \\Application\\Model\\Article::class,\n    'hydrator' => \\Zend\\Hydrator\\ObjectProperty::class,\n    'linked_tables' => [\n      'author' => [\n        'name' => 'authors',\n        'type' => 'one_to_one',\n      ]\n    ]\n  ],\n  'authors' => [\n    'table_name' => 'authors',\n    'entity' => \\Application\\Model\\Author::class,\n    'hydrator' => \\Zend\\Hydrator\\ObjectProperty::class,\n  ]\n]  Then use it:  // $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n$table = $manager->get('articles');\n$article = $table->fetchWithId(3);\n\n// Outputs: \"I like Jellyfish\"\necho $article->title;\n\n// Outputs: \"Fake Name\"\necho $article->author->name;",
            "title": "One-to-One relationships"
        },
        {
            "location": "/retrieving/#one-to-many-relationships",
            "text": "With a table  articles :     id  title      1  Sweet Baby Ray's is the best!    2  PB&J is yummy    3  I like Jellyfish     and another table  comments :     id  comment  article_id      1  This is the best article ever!  1    2  I hated this!  1    3  I am a lost prince and I have money.  2     Start by modeling the entity for both:  The article:  namespace Application\\Model;\nclass Article {\n  public $id,$title;\n}  and the author  namespace Application\\Model;\nclass Comment {\n  public $id,$comment;\n}  Then in the config, define both the  articles  and  comments  table and use the  linked_tables  key to configure the relationship:  'auto_tables' => [\n  'articles' => [\n    'table_name' => 'articles',\n    'entity' => \\Application\\Model\\Article::class,\n    'hydrator' => \\Zend\\Hydrator\\ObjectProperty::class,\n    'linked_tables' => [\n      'author' => [\n        'name' => 'authors',\n        'type' => 'one_to_many',\n        'remote_column' => 'arcticle_id',\n        'local_column' => 'id',\n      ]\n    ]\n  ],\n  'comments' => [\n    'table_name' => 'comments',\n    'entity' => \\Application\\Model\\Comment::class,\n    'hydrator' => \\Zend\\Hydrator\\ObjectProperty::class,\n  ]\n]  Then use it:  // $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n$table = $manager->get('articles');\n$article = $table->fetchWithId(1);\n\n// Outputs: \"Sweet Baby Ray's is the best!\"\necho $article->title;\n\n// Outputs: \"This is the best article ever!\" and \"I hated this!\"\nforeach($article->comments as $comment) {\n  echo $comment->comment;\n}",
            "title": "One-to-Many relationships"
        },
        {
            "location": "/retrieving/#many-to-many-relationships",
            "text": "With a table  articles :     id  title      1  Sweet Baby Ray's is the best!    2  PB&J is yummy    3  I like Jellyfish     and another table  authors :     id  Name      1  Nathan Smith    2  Fake Name    3  Jimmy Boi    4  John Doe     and a mapping table  articles_authors_map :     article_id  author_id      1  1    1  3    2  3    3  4    3  2     Start by modeling the entity for both:  The article:  namespace Application\\Model;\nclass Article {\n  public $id,$title,$authors;\n}  and the author  namespace Application\\Model;\nclass Author {\n  public $id,$name,$articles;\n}  Then in the config, define both the  articles  ,  authors , and  articles_authors_map  tables and use the  linked_tables  key for the  articles  and  authors  table to configure the two-way relationship:  'auto_tables' => [\n  'articles' => [\n    'table_name' => 'articles',\n    'entity' => \\Application\\Model\\Article::class,\n    'hydrator' => \\Zend\\Hydrator\\ObjectProperty::class,\n    'linked_tables' => [\n      'authors' => [\n        'type' => 'many_to_many',\n        'remote_table' => 'authors',\n        'mapping_table' => 'articles_authors_map',\n        'local_column' => 'id',\n        'local_property' => 'id',\n        'local_mapping_column' => 'article_id',\n        'remote_mapping_column' => 'author_id',\n        'remote_column' => 'id',\n      ]\n    ]\n  ],\n  'authors' => [\n    'table_name' => 'authors',\n    'entity' => \\Application\\Model\\Author::class,\n    'hydrator' => \\Zend\\Hydrator\\ObjectProperty::class,\n    'linked_tables' => [\n      'articles' => [\n        'type' => 'many_to_many',\n        'remote_table' => 'authors',\n        'mapping_table' => 'articles_authors_map',\n        'local_column' => 'id',\n        'local_property' => 'id',\n        'local_mapping_column' => 'author_id',\n        'remote_mapping_column' => 'article_id',\n        'remote_column' => 'id',\n      ]\n    ]\n  ],\n  'articles_authors_map' => [\n    'table_name' => 'articles_authors_map',\n  ]\n]  Then use it:  // $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n$table = $manager->get('articles');\n$article = $table->fetchWithId(3);\n\n// Outputs: \"I like Jellyfish\"\necho $article->title;\n\n// Outputs: \"John Doe\" and \"Fake Name\"\nforeach($article->authors as $author) {\n  echo $author->name;\n}\n\n$table = $manager->get('authors');\n$author = $table->fetchWithId(3);\n\n// Outputs: \"Jimmy Boi\"\necho $author->name;\n\n// Outputs: \"Sweet Baby Ray's is the best!\" and \"PB&J is yummy\"\nforeach($author->articles as $article) {\n  echo $article->title;\n}",
            "title": "Many-to-many relationships"
        },
        {
            "location": "/retrieving/#relationships-arent-one-level-deep",
            "text": "Any linked tabled contain all the defined relationships all the time  With a table  articles :     id  title  author      1  Sweet Baby Ray's is the best!  1    2  PB&J is yummy  1    3  I like Jellyfish  2     and another table  authors :     id  Name  Car      1  Nathan Smith  2    2  Fake Name  1     and another table  cars :     id  name      1  Honda Civic    2  Tesla Model 3     Start by modeling the entity for all:  The article:  namespace Application\\Model;\nclass Article {\n  public $id,$title,$author;\n}  and the author  namespace Application\\Model;\nclass Author {\n  public $id,$name,$car;\n}  and the car  namespace Application\\Model;\nclass Car {\n  public $id,$name,$car;\n}  Then in the config, define the  articles ,   authors , and  cars  tables and use the  linked_tables  key to configure the relationships:  'auto_tables' => [\n  'articles' => [\n    'table_name' => 'articles',\n    'entity' => \\Application\\Model\\Article::class,\n    'hydrator' => \\Zend\\Hydrator\\ObjectProperty::class,\n    'linked_tables' => [\n      'author' => [\n        'name' => 'authors',\n        'type' => 'one_to_one',\n      ]\n    ]\n  ],\n  'authors' => [\n    'table_name' => 'authors',\n    'entity' => \\Application\\Model\\Author::class,\n    'hydrator' => \\Zend\\Hydrator\\ObjectProperty::class,\n    'linked_tables' => [\n      'car' => [\n        'name' => 'cars',\n        'type' => 'one_to_one',\n      ]\n    ]\n  ],\n  'cars' => [\n    'table_name' => 'cars',\n    'entity' => \\Application\\Model\\Car::class,\n    'hydrator' => \\Zend\\Hydrator\\ObjectProperty::class,\n  ]\n]  Then use it:  // $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n$table = $manager->get('articles');\n$article = $table->fetchWithId(3);\n\n// Outputs: \"I like Jellyfish\"\necho $article->title;\n\n// Outputs: \"Fake Name\"\necho $article->author->name;\n\n// Outputs: \"Honda Civic\"\necho $article->author->car->name;",
            "title": "Relationships aren't one level deep"
        },
        {
            "location": "/saving/",
            "text": "Saving Records\n\n\nOnce your relationships are configured to retrieve records, you can save the records as well as seen in the section below.\n\n\nFlat record\n\n\nWith a table \narticles\n:\n\n\n\n\n\n\n\n\nid\n\n\ntitle\n\n\n\n\n\n\n\n\n\n\n1\n\n\nSweet Baby Ray's is the best!\n\n\n\n\n\n\n2\n\n\nPB&J is yummy\n\n\n\n\n\n\n3\n\n\nI like Jellyfish\n\n\n\n\n\n\n\n\n Create a record \n\n\n// $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n\n$article = $manager->createNew('articles');\n$article->title \"I like AutoTable\"\n\n// Persist all pending changes\n$manager->flush();\n\n// See the results\n$article = $articles->fetchWithId(4);\n\n// Outputs: \"I like AutoTable\"\necho $artcle->title;\n\n\n\n\n Make changes \n\n\n// $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n\n$articles = $manager->getTable('articles');\n// Get the article\n$article = $articles->fetchWithId(3);\n\n// Outputs: \"I like Jellyfish\"\necho $article->title\n\n// Make changes\n$article->title = \"Jellyfish are gross\"\n\n// Persist all pending changes\n$manager->flush();\n\n// See the results\n$article = $articles->fetchWithId(3);\n\n// Outputs: \"Jellyfish are gross\"\necho $artcle->title;\n\n\n\n\n Delete a Record \n\n\n// $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n\n$article = $articles->fetchWithId(3);\n\n// Delete the article\n$manager->delete($article);\n\n// Persist all pending changes\n$manager->flush();\n\n// $article will be null\n$article = $articles->fetchWithId(3);\n\n\n\n\nOne-to-Many\n\n\n Create and link a record \n\n\n// $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n\n$articles = $manager->getTable('articles');\n\n// Create the comment\n$comment1 = $manager->createNew('comments');\n$comment1->comment = 'This is a new comment';\n\n// Bind it to the article\n$comment1->article = $articles->fetchWithId(1);\n// or\n$comment1->article = 1;\n\n$comment2 = $manager->createNew('comments');\n$comment2->comment = 'Comments are great';\n\n// Bind it to the article\n$comment2->article = $articles->fetchWithId(1);\n// or\n$comment2->article = 1;\n\n// Persist all pending changes\n$manager->flush();\n\n// See the results\n$article = $articles->fetchWithId(1);\n// Outputs \"This is a new comment\" and \"Comments are great\"\nforeach($article->comments as $comment) {\n    echo $comment->comment;\n}\n\n\n\n\n Unlink a record \n\n\n// $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n\n$comments = $manager->getTable('comments');\n\n$comment = $comments->fetchWithId(1);\n$comment->article = null;\n\n// Persist all pending changes\n$manager->flush();\n\n\n\n\nMany-to-Many\n\n\nWith a table \nauthors\n:\n\n\n\n\n\n\n\n\nid\n\n\nname\n\n\n\n\n\n\n\n\n\n\n1\n\n\nNathan Smith\n\n\n\n\n\n\n2\n\n\nJohn Doe\n\n\n\n\n\n\n\n\nand another table \ncars\n:\n\n\n\n\n\n\n\n\nid\n\n\nname\n\n\n\n\n\n\n\n\n\n\n1\n\n\nTesla Model 3\n\n\n\n\n\n\n2\n\n\nHonda Civic\n\n\n\n\n\n\n3\n\n\nIce Cream Bus\n\n\n\n\n\n\n4\n\n\nTow Truck\n\n\n\n\n\n\n\n\nand a mapping table \nauthor_car_map\n:\n\n\n\n\n\n\n\n\nauthor_id\n\n\ncar_id\n\n\n\n\n\n\n\n\n\n\n1\n\n\n3\n\n\n\n\n\n\n2\n\n\n4\n\n\n\n\n\n\n\n\n Link a Record \n\n\n// $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n\n$authors = $manager->getTable('authors');\n$cars = $manager->getTable('cars');\n\n// Get the author and desired car\n$author = $authors->fetchWithId(1);\n$car = $cars->fetchWithId(1);\n\n// Give a Tesla to Nathan.\n$manager->link($car,$author);\n\n$manager->flush();\n\nforeach($author->cars as $car) {\n    // Outputs: \"Ice Cream Bus\" and \"Tesla Model 3\"\n    echo $car->name;\n}\n\n\n\n\n Unlink a Record \n\n\n// $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n\n$authors = $manager->getTable('authors');\n$cars = $manager->getTable('cars');\n\n// Get the author and desired car\n$author = $authors->fetchWithId(1);\n$car = $cars->fetchWithId(3);\n\n// Take an Ice Cream bus away from Nathan :\"( sad day.\n$manager->unlink($car,$author);\n\n$manager->flush();\n\nforeach($author->cars as $car) {\n    // Assuming you linked the record in the previous example above, Outputs: \"Tesla Model 3\"\n    echo $car->name;\n}",
            "title": "Save Records"
        },
        {
            "location": "/saving/#saving-records",
            "text": "Once your relationships are configured to retrieve records, you can save the records as well as seen in the section below.",
            "title": "Saving Records"
        },
        {
            "location": "/saving/#flat-record",
            "text": "With a table  articles :     id  title      1  Sweet Baby Ray's is the best!    2  PB&J is yummy    3  I like Jellyfish      Create a record   // $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n\n$article = $manager->createNew('articles');\n$article->title \"I like AutoTable\"\n\n// Persist all pending changes\n$manager->flush();\n\n// See the results\n$article = $articles->fetchWithId(4);\n\n// Outputs: \"I like AutoTable\"\necho $artcle->title;   Make changes   // $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n\n$articles = $manager->getTable('articles');\n// Get the article\n$article = $articles->fetchWithId(3);\n\n// Outputs: \"I like Jellyfish\"\necho $article->title\n\n// Make changes\n$article->title = \"Jellyfish are gross\"\n\n// Persist all pending changes\n$manager->flush();\n\n// See the results\n$article = $articles->fetchWithId(3);\n\n// Outputs: \"Jellyfish are gross\"\necho $artcle->title;   Delete a Record   // $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n\n$article = $articles->fetchWithId(3);\n\n// Delete the article\n$manager->delete($article);\n\n// Persist all pending changes\n$manager->flush();\n\n// $article will be null\n$article = $articles->fetchWithId(3);",
            "title": "Flat record"
        },
        {
            "location": "/saving/#one-to-many",
            "text": "Create and link a record   // $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n\n$articles = $manager->getTable('articles');\n\n// Create the comment\n$comment1 = $manager->createNew('comments');\n$comment1->comment = 'This is a new comment';\n\n// Bind it to the article\n$comment1->article = $articles->fetchWithId(1);\n// or\n$comment1->article = 1;\n\n$comment2 = $manager->createNew('comments');\n$comment2->comment = 'Comments are great';\n\n// Bind it to the article\n$comment2->article = $articles->fetchWithId(1);\n// or\n$comment2->article = 1;\n\n// Persist all pending changes\n$manager->flush();\n\n// See the results\n$article = $articles->fetchWithId(1);\n// Outputs \"This is a new comment\" and \"Comments are great\"\nforeach($article->comments as $comment) {\n    echo $comment->comment;\n}   Unlink a record   // $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n\n$comments = $manager->getTable('comments');\n\n$comment = $comments->fetchWithId(1);\n$comment->article = null;\n\n// Persist all pending changes\n$manager->flush();",
            "title": "One-to-Many"
        },
        {
            "location": "/saving/#many-to-many",
            "text": "With a table  authors :     id  name      1  Nathan Smith    2  John Doe     and another table  cars :     id  name      1  Tesla Model 3    2  Honda Civic    3  Ice Cream Bus    4  Tow Truck     and a mapping table  author_car_map :     author_id  car_id      1  3    2  4      Link a Record   // $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n\n$authors = $manager->getTable('authors');\n$cars = $manager->getTable('cars');\n\n// Get the author and desired car\n$author = $authors->fetchWithId(1);\n$car = $cars->fetchWithId(1);\n\n// Give a Tesla to Nathan.\n$manager->link($car,$author);\n\n$manager->flush();\n\nforeach($author->cars as $car) {\n    // Outputs: \"Ice Cream Bus\" and \"Tesla Model 3\"\n    echo $car->name;\n}   Unlink a Record   // $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n\n$authors = $manager->getTable('authors');\n$cars = $manager->getTable('cars');\n\n// Get the author and desired car\n$author = $authors->fetchWithId(1);\n$car = $cars->fetchWithId(3);\n\n// Take an Ice Cream bus away from Nathan :\"( sad day.\n$manager->unlink($car,$author);\n\n$manager->flush();\n\nforeach($author->cars as $car) {\n    // Assuming you linked the record in the previous example above, Outputs: \"Tesla Model 3\"\n    echo $car->name;\n}",
            "title": "Many-to-Many"
        },
        {
            "location": "/config/",
            "text": "Configuration Options\n\n\nWithin the \nServiceManager\n config key \nauto_tables\n:\n\n\n\n\n\n\n\n\nkey\n\n\ntype\n\n\ndescription\n\n\nrequired\n\n\ndefault\n\n\n\n\n\n\n\n\n\n\ntable_name\n\n\nstring\n\n\nThe name of the table in the DB.\n\n\ntrue\n\n\nNone\n\n\n\n\n\n\ntable\n\n\nstring\n\n\nThe ServiceManager key to pull for the table class. Returned class must implement the \nAutoTable\\TableInterface\n interface.\n\n\nfalse\n\n\nAutoTable\\BaseTable\n\n\n\n\n\n\nentity\n\n\nstring\n\n\nEither a \nServiceManager\n key or the Fully-Qualified Class Name of the entity to use.\n\n\nfalse if only for a many-to-many mapping table, otherwise true\n\n\nNone\n\n\n\n\n\n\nhydrator\n\n\nstring\n\n\nEither a \nServiceManager\n key or the Fully-Qualified Class Name of the hydrator to use.\n\n\nfalse if only for a many-to-many mapping table, otherwise true\n\n\nNone\n\n\n\n\n\n\nid_column\n\n\nstring\n\n\nThe name of the primary column in the DB for this table.\n\n\nfalse\n\n\n\"id\"\n\n\n\n\n\n\nprimary_property\n\n\nstring\n\n\nThe name of the primary property in the entity.\n\n\nfalse\n\n\n\"id\"\n\n\n\n\n\n\nlinked_tables\n\n\narray of \nLinkedTableConfig\n\n\nEach key should be the property to link to another table, and each value should be a \nLinkedTableConfig\n array.\n\n\nfalse\n\n\nnull\n\n\n\n\n\n\n\n\nLinkedTableConfig\n\n\n\n\n\n\n\n\nkey\n\n\ntype\n\n\ndescription\n\n\nrequired\n\n\ndefault\n\n\n\n\n\n\n\n\n\n\nalias_to\n\n\nstring\n\n\nUse this if you want to map a friendlier name to a column. For example, mapping \"author\" to \"authorId\". Specify the LinkedTableConfig you want to alias. \nIf specified, all other keys are ignored.\n\n\nfalse\n\n\nnull\n\n\n\n\n\n\ntype\n\n\nstring Enum\n\n\nMay be \none_to_one\n, \none_to_many\n, \nmany_to_many\n. Depending on which of these is set, the required settings change.\n\n\ntrue\n\n\nNone\n\n\n\n\n\n\nname\n\n\nstring\n\n\nThe table to link to. This is a key in the \nauto_tables\n config, not a DB table name.\n\n\ntrue\n\n\nNone\n\n\n\n\n\n\nshould_save\n\n\nbool\n\n\nWhen using \nalias_to\n or a \none_to_many\n or \nmany_to_many\n type, the key is automatically removed from the data before saving to the DB as these properties typically don't represent real columns. To turn off this behavior for single properties, set this to true.\n\n\nfalse\n\n\nfalse\n\n\n\n\n\n\nremote_column\n\n\nstring\n\n\nThe DB column name in the remote table to link to.\n\n\ntrue if \none_to_many\n or \nmany_to_many\n\n\nNone\n\n\n\n\n\n\nlocal_property\n\n\nstring\n\n\nThe entity property use when linking to the remote table.\n\n\ntrue if \none_to_many\n or \nmany_to_many\n\n\nNone\n\n\n\n\n\n\nlocal_column\n\n\nstring\n\n\nThe DB column to link to the mapping table for the primary table.\n\n\ntrue if \nmany_to_many\n\n\nNone\n\n\n\n\n\n\nlocal_mapping_column\n\n\nstring\n\n\nThe DB column of the mapping table to link to the local column.\n\n\ntrue if \nmany_to_many\n\n\nNone\n\n\n\n\n\n\nremote_mapping_column\n\n\nstring\n\n\nThe DB column of the mapping table to link to the remote column.\n\n\ntrue if \nmany_to_many\n\n\nNone\n\n\n\n\n\n\n\n\nTo help illustrate the \nmany_to_many\n options, here is a diagram for an \narticles\n table:\n\n\narticles\n:\n\n\n\n\n\n\n\n\nid (local_column)\n\n\ntitle\n\n\n\n\n\n\n\n\n\n\n1\n\n\nSweet Baby Ray's is the best!\n\n\n\n\n\n\n\n\nauthors\n:\n\n\n\n\n\n\n\n\nid (remote_column)\n\n\nName\n\n\n\n\n\n\n\n\n\n\n2\n\n\nNathan Smith\n\n\n\n\n\n\n\n\narticles_authors_map\n:\n\n\n\n\n\n\n\n\narticle_id (local_mapping_column)\n\n\nauthor_id (remote_mapping_column)\n\n\n\n\n\n\n\n\n\n\n1\n\n\n2",
            "title": "Configuration"
        },
        {
            "location": "/config/#configuration-options",
            "text": "Within the  ServiceManager  config key  auto_tables :     key  type  description  required  default      table_name  string  The name of the table in the DB.  true  None    table  string  The ServiceManager key to pull for the table class. Returned class must implement the  AutoTable\\TableInterface  interface.  false  AutoTable\\BaseTable    entity  string  Either a  ServiceManager  key or the Fully-Qualified Class Name of the entity to use.  false if only for a many-to-many mapping table, otherwise true  None    hydrator  string  Either a  ServiceManager  key or the Fully-Qualified Class Name of the hydrator to use.  false if only for a many-to-many mapping table, otherwise true  None    id_column  string  The name of the primary column in the DB for this table.  false  \"id\"    primary_property  string  The name of the primary property in the entity.  false  \"id\"    linked_tables  array of  LinkedTableConfig  Each key should be the property to link to another table, and each value should be a  LinkedTableConfig  array.  false  null",
            "title": "Configuration Options"
        },
        {
            "location": "/config/#linkedtableconfig",
            "text": "key  type  description  required  default      alias_to  string  Use this if you want to map a friendlier name to a column. For example, mapping \"author\" to \"authorId\". Specify the LinkedTableConfig you want to alias.  If specified, all other keys are ignored.  false  null    type  string Enum  May be  one_to_one ,  one_to_many ,  many_to_many . Depending on which of these is set, the required settings change.  true  None    name  string  The table to link to. This is a key in the  auto_tables  config, not a DB table name.  true  None    should_save  bool  When using  alias_to  or a  one_to_many  or  many_to_many  type, the key is automatically removed from the data before saving to the DB as these properties typically don't represent real columns. To turn off this behavior for single properties, set this to true.  false  false    remote_column  string  The DB column name in the remote table to link to.  true if  one_to_many  or  many_to_many  None    local_property  string  The entity property use when linking to the remote table.  true if  one_to_many  or  many_to_many  None    local_column  string  The DB column to link to the mapping table for the primary table.  true if  many_to_many  None    local_mapping_column  string  The DB column of the mapping table to link to the local column.  true if  many_to_many  None    remote_mapping_column  string  The DB column of the mapping table to link to the remote column.  true if  many_to_many  None     To help illustrate the  many_to_many  options, here is a diagram for an  articles  table:  articles :     id (local_column)  title      1  Sweet Baby Ray's is the best!     authors :     id (remote_column)  Name      2  Nathan Smith     articles_authors_map :     article_id (local_mapping_column)  author_id (remote_mapping_column)      1  2",
            "title": "LinkedTableConfig"
        },
        {
            "location": "/codebase-integration/",
            "text": "Integrating into your code\n\n\nFor most cases it should be fairly straighforward to use. However, there are some things to keep in mind when.\n\n\nAll tracked objects are \nProxy\n objects\n\n\nAll of the objects within the system are basically wrapped around your native objects. Changes made to objects that aren't being tracked won't be persisted when \nflush\n is called.\n\n\nHere are a few examples:\n\n\n// $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n$table = $manager->getTable('articles');\n$entity = $table->fetchWithId(2);\n\n// Outputs: \"AutoTable\\Proxy\"\necho get_class($entity);\n\n\n\n\n// $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n\n$untracked_article = new \\Application\\Model\\Article();\n\n// Outputs: \"Application\\Model\\Article\"\necho get_class($untracked_article);\n\n$tracked_article = $manager->track($untracked_article,'articles');\n\n// Outputs: \"AutoTable\\Proxy\"\necho get_class($tracked_article);\n\n\n\n\nTracking changes to untracked objects\n\n\nAs previously stated, any changes made to objects untracked won't be persisted when \nflush\n is called. However, you can still work with your raw objects as long as you track them before calling \nflush\n.\n\n\n\n\nNote:\n Keep in mind, the features of this module aren't available for raw objects. None of your linked tables will be available unless you are operating on a \nProxy\n object.\n\n\n\n\nSaving a new record using an untracked object\n\n\n$untracked_article = new \\Application\\Model\\Article();\n$untracked_article->title = 'Yay, an article!';\n\n// $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n\n// Here is where we track it\n$tracked_article = $manager->track($untracked_article,'articles');\n\n// Force a sync when flush is called\n$manager->queueSync($tracked_article);\n\n// Changes will be picked up and saved. In this case, a new record.\n$manager->flush();\n\n\n\n\nUpdating a record using an untracked object\n\n\n// Either created like this or retrieved out of a Proxy object with __getObject()\n$untracked_article = new \\Application\\Model\\Article();\n$untracked_article->id = 123;\n$untracked_article->title = 'Yay, an article!';\n\n// $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n\n// Here is where we track it\n$tracked_article = $manager->track($untracked_article,'articles');\n\n// Force a sync when flush is called\n$manager->queueSync($tracked_article);\n\n// Changes will be picked up and saved. In this case, a new record.\n$manager->flush();\n\n\n\n\nThe call to \nqueueSync\n is unecessary if you make changes after it is tracked:\n\n\n$untracked_article = new \\Application\\Model\\Article();\n\n// Track it\n$tracked_article = $manager->track($untracked_article,'articles');\n\n// Any changes automatically trigger a sync\n$untracked_article->title = 'Yay, an article!';\n\n$manager->flush();\n\n\n\n\nExtracting the underlying object from the Proxy using \nProxy::__getObject\n\n\nYou are also able to extract the underlying object as seen below.\n\n\n\n\nNote:\n Doing this removes it from tracking.\n  To persist changes to the extracted untracked object, use one of the methods from above.\n\n\n\n\n// $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n$table = $manager->getTable('articles');\n\n$tracked_article = $table->fetchWithId(2);\n\n// Outputs: \"AutoTable\\Proxy\"\necho get_class($tracked_article);\n\n$untracked_article = $tracked_article->__getObject();\n\n// Outputs: \"Application\\Model\\Article\"\necho get_class($untracked_article);\n\n\n\n\nUsing a custom table class\n\n\nBy default the \nAutoTable\\BaseTable\n is used for all of the lookups. If you wish to implement your own for custom data retrievals, simply set it up in the ServiceManager and set the \ntable\n key in the \ntable config\n.\n\n\nIt must implement the \nAutoTable\\TableInterface\n or simply extend \nAutoTable\\BaseTable\n. You don't have to do anything special with the results so long as the data returned can be hydrated by the specified hydrator. Refer to the BaseTable for examples of code.",
            "title": "Codebase Integration"
        },
        {
            "location": "/codebase-integration/#integrating-into-your-code",
            "text": "For most cases it should be fairly straighforward to use. However, there are some things to keep in mind when.",
            "title": "Integrating into your code"
        },
        {
            "location": "/codebase-integration/#all-tracked-objects-are-proxy-objects",
            "text": "All of the objects within the system are basically wrapped around your native objects. Changes made to objects that aren't being tracked won't be persisted when  flush  is called.  Here are a few examples:  // $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n$table = $manager->getTable('articles');\n$entity = $table->fetchWithId(2);\n\n// Outputs: \"AutoTable\\Proxy\"\necho get_class($entity);  // $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n\n$untracked_article = new \\Application\\Model\\Article();\n\n// Outputs: \"Application\\Model\\Article\"\necho get_class($untracked_article);\n\n$tracked_article = $manager->track($untracked_article,'articles');\n\n// Outputs: \"AutoTable\\Proxy\"\necho get_class($tracked_article);",
            "title": "All tracked objects are Proxy objects"
        },
        {
            "location": "/codebase-integration/#tracking-changes-to-untracked-objects",
            "text": "As previously stated, any changes made to objects untracked won't be persisted when  flush  is called. However, you can still work with your raw objects as long as you track them before calling  flush .   Note:  Keep in mind, the features of this module aren't available for raw objects. None of your linked tables will be available unless you are operating on a  Proxy  object.",
            "title": "Tracking changes to untracked objects"
        },
        {
            "location": "/codebase-integration/#saving-a-new-record-using-an-untracked-object",
            "text": "$untracked_article = new \\Application\\Model\\Article();\n$untracked_article->title = 'Yay, an article!';\n\n// $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n\n// Here is where we track it\n$tracked_article = $manager->track($untracked_article,'articles');\n\n// Force a sync when flush is called\n$manager->queueSync($tracked_article);\n\n// Changes will be picked up and saved. In this case, a new record.\n$manager->flush();",
            "title": "Saving a new record using an untracked object"
        },
        {
            "location": "/codebase-integration/#updating-a-record-using-an-untracked-object",
            "text": "// Either created like this or retrieved out of a Proxy object with __getObject()\n$untracked_article = new \\Application\\Model\\Article();\n$untracked_article->id = 123;\n$untracked_article->title = 'Yay, an article!';\n\n// $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n\n// Here is where we track it\n$tracked_article = $manager->track($untracked_article,'articles');\n\n// Force a sync when flush is called\n$manager->queueSync($tracked_article);\n\n// Changes will be picked up and saved. In this case, a new record.\n$manager->flush();  The call to  queueSync  is unecessary if you make changes after it is tracked:  $untracked_article = new \\Application\\Model\\Article();\n\n// Track it\n$tracked_article = $manager->track($untracked_article,'articles');\n\n// Any changes automatically trigger a sync\n$untracked_article->title = 'Yay, an article!';\n\n$manager->flush();",
            "title": "Updating a record using an untracked object"
        },
        {
            "location": "/codebase-integration/#extracting-the-underlying-object-from-the-proxy-using-proxy__getobject",
            "text": "You are also able to extract the underlying object as seen below.   Note:  Doing this removes it from tracking.\n  To persist changes to the extracted untracked object, use one of the methods from above.   // $serviceLocator is an instance of the main ServiceManager\n$manager = $serviceLocator->get(\\AutoTable\\AutoTableManager::class);\n$table = $manager->getTable('articles');\n\n$tracked_article = $table->fetchWithId(2);\n\n// Outputs: \"AutoTable\\Proxy\"\necho get_class($tracked_article);\n\n$untracked_article = $tracked_article->__getObject();\n\n// Outputs: \"Application\\Model\\Article\"\necho get_class($untracked_article);",
            "title": "Extracting the underlying object from the Proxy using Proxy::__getObject"
        },
        {
            "location": "/codebase-integration/#using-a-custom-table-class",
            "text": "By default the  AutoTable\\BaseTable  is used for all of the lookups. If you wish to implement your own for custom data retrievals, simply set it up in the ServiceManager and set the  table  key in the  table config .  It must implement the  AutoTable\\TableInterface  or simply extend  AutoTable\\BaseTable . You don't have to do anything special with the results so long as the data returned can be hydrated by the specified hydrator. Refer to the BaseTable for examples of code.",
            "title": "Using a custom table class"
        }
    ]
}